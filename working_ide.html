<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Simple Programming Language - Working IDE</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1e1e1e;
            color: white;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .ide-layout {
            display: flex;
            gap: 20px;
            height: 500px;
        }
        .editor-panel, .output-panel {
            flex: 1;
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 5px;
        }
        .panel-header {
            background: #333;
            padding: 10px;
            border-bottom: 1px solid #444;
            font-weight: bold;
        }
        .editor-content, .output-content {
            height: calc(100% - 40px);
            padding: 10px;
        }
        #code-editor {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: #f8f8f2;
            border: none;
            outline: none;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: none;
        }
        #output {
            height: 100%;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
        }
        .controls {
            margin: 20px 0;
            text-align: center;
        }
        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .btn:hover {
            background: #45a049;
        }
        .btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .btn-clear {
            background: #f44336;
        }
        .btn-clear:hover {
            background: #da190b;
        }
        .status {
            text-align: center;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .output-line {
            color: #00ff00;
            margin: 2px 0;
        }
        .error-line {
            color: #ff4444;
            margin: 2px 0;
        }
        .print-line {
            color: #ffffff;
            margin: 2px 0;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Simple Programming Language - Working IDE</h1>
            <div id="status" class="status">Loading...</div>
        </div>

        <div class="controls">
            <button id="run-btn" class="btn" disabled>Run Code</button>
            <button id="clear-btn" class="btn btn-clear">Clear Output</button>
            <button id="example-btn" class="btn">Load Example</button>
        </div>

        <div class="ide-layout">
            <div class="editor-panel">
                <div class="panel-header">Code Editor</div>
                <div class="editor-content">
                    <textarea id="code-editor" placeholder="Enter your SPL code here...">x = 5
print("Hello, World!")
print("x =", x)</textarea>
                </div>
            </div>

            <div class="output-panel">
                <div class="panel-header">Output</div>
                <div class="output-content">
                    <div id="output">Ready to run code...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let pyodide;
        let interpreter;

        // Complete working SPL implementation
        const languageCode = `
# Token Types
from enum import Enum

class TokenType(Enum):
    NUMBER = "NUMBER"
    PLUS = "PLUS"
    MINUS = "MINUS"
    MULTIPLY = "MULTIPLY"
    DIVIDE = "DIVIDE"
    LPAREN = "LPAREN"
    RPAREN = "RPAREN"
    IDENTIFIER = "IDENTIFIER"
    STRING = "STRING"
    ASSIGN = "ASSIGN"
    IF = "IF"
    ELSE = "ELSE"
    WHILE = "WHILE"
    GREATER = "GREATER"
    LESS = "LESS"
    COLON = "COLON"
    EOF = "EOF"
    NEWLINE = "NEWLINE"
    PRINT = "PRINT"
    COMMA = "COMMA"

# Token class
class Token:
    def __init__(self, type, value, line=1, column=1):
        self.type = type
        self.value = value
        self.line = line
        self.column = column

# Lexer
class Lexer:
    def __init__(self, text):
        self.text = text
        self.pos = 0
        self.line = 1
        self.column = 1
        
    def error(self, message="Invalid character"):
        raise Exception(f"Lexer error at line {self.line}, column {self.column}: {message}")
    
    def peek(self, offset=0):
        pos = self.pos + offset
        if pos >= len(self.text):
            return None
        return self.text[pos]
    
    def advance(self):
        if self.pos < len(self.text) and self.text[self.pos] == '\\n':
            self.line += 1
            self.column = 1
        else:
            self.column += 1
        self.pos += 1
    
    def skip_whitespace(self):
        while self.pos < len(self.text) and self.text[self.pos] in ' \\t':
            self.advance()
    
    def skip_comment(self):
        while self.pos < len(self.text) and self.text[self.pos] != '\\n':
            self.advance()
    
    def read_number(self):
        result = ""
        while self.pos < len(self.text) and (self.text[self.pos].isdigit() or self.text[self.pos] == '.'):
            result += self.text[self.pos]
            self.advance()
        
        if '.' in result:
            return float(result)
        return int(result)
    
    def read_string(self):
        result = ""
        self.advance()  # Skip opening quote
        
        while self.pos < len(self.text) and self.text[self.pos] != '"':
            result += self.text[self.pos]
            self.advance()
        
        if self.pos >= len(self.text):
            self.error("Unterminated string")
        
        self.advance()  # Skip closing quote
        return result
    
    def read_identifier(self):
        result = ""
        while (self.pos < len(self.text) and 
               (self.text[self.pos].isalnum() or self.text[self.pos] == '_')):
            result += self.text[self.pos]
            self.advance()
        return result
    
    def tokenize(self):
        tokens = []
        
        while self.pos < len(self.text):
            self.skip_whitespace()
            
            if self.pos >= len(self.text):
                break
            
            char = self.text[self.pos]
            
            # Comments
            if char == '#':
                self.skip_comment()
                continue
            
            # Newlines
            if char == '\\n':
                tokens.append(Token(TokenType.NEWLINE, '\\n', self.line, self.column))
                self.advance()
                continue
            
            # Numbers
            if char.isdigit():
                tokens.append(Token(TokenType.NUMBER, self.read_number(), self.line, self.column))
                continue
            
            # Strings
            if char == '"':
                tokens.append(Token(TokenType.STRING, self.read_string(), self.line, self.column))
                continue
            
            # Identifiers and keywords
            if char.isalpha() or char == '_':
                identifier = self.read_identifier()
                if identifier == 'if':
                    tokens.append(Token(TokenType.IF, identifier, self.line, self.column))
                elif identifier == 'else':
                    tokens.append(Token(TokenType.ELSE, identifier, self.line, self.column))
                elif identifier == 'while':
                    tokens.append(Token(TokenType.WHILE, identifier, self.line, self.column))
                elif identifier == 'print':
                    tokens.append(Token(TokenType.PRINT, identifier, self.line, self.column))
                else:
                    tokens.append(Token(TokenType.IDENTIFIER, identifier, self.line, self.column))
                continue
            
            # Single character tokens
            if char == '+':
                tokens.append(Token(TokenType.PLUS, char, self.line, self.column))
                self.advance()
            elif char == '-':
                tokens.append(Token(TokenType.MINUS, char, self.line, self.column))
                self.advance()
            elif char == '*':
                tokens.append(Token(TokenType.MULTIPLY, char, self.line, self.column))
                self.advance()
            elif char == '/':
                tokens.append(Token(TokenType.DIVIDE, char, self.line, self.column))
                self.advance()
            elif char == '(':
                tokens.append(Token(TokenType.LPAREN, char, self.line, self.column))
                self.advance()
            elif char == ')':
                tokens.append(Token(TokenType.RPAREN, char, self.line, self.column))
                self.advance()
            elif char == '=':
                tokens.append(Token(TokenType.ASSIGN, char, self.line, self.column))
                self.advance()
            elif char == '>':
                tokens.append(Token(TokenType.GREATER, char, self.line, self.column))
                self.advance()
            elif char == '<':
                tokens.append(Token(TokenType.LESS, char, self.line, self.column))
                self.advance()
            elif char == ':':
                tokens.append(Token(TokenType.COLON, char, self.line, self.column))
                self.advance()
            elif char == ',':
                tokens.append(Token(TokenType.COMMA, char, self.line, self.column))
                self.advance()
            else:
                self.error(f"Unexpected character '{char}'")
        
        tokens.append(Token(TokenType.EOF, None, self.line, self.column))
        return tokens

# AST Node classes
class ASTNode:
    pass

class Number(ASTNode):
    def __init__(self, value):
        self.value = value

class String(ASTNode):
    def __init__(self, value):
        self.value = value

class Identifier(ASTNode):
    def __init__(self, name):
        self.name = name

class BinaryOp(ASTNode):
    def __init__(self, left, operator, right):
        self.left = left
        self.operator = operator
        self.right = right

class UnaryOp(ASTNode):
    def __init__(self, operator, operand):
        self.operator = operator
        self.operand = operand

class Assignment(ASTNode):
    def __init__(self, name, value):
        self.name = name
        self.value = value

class PrintStatement(ASTNode):
    def __init__(self, arguments):
        self.arguments = arguments

class IfStatement(ASTNode):
    def __init__(self, condition, if_body, else_body=None):
        self.condition = condition
        self.if_body = if_body
        self.else_body = else_body

class WhileStatement(ASTNode):
    def __init__(self, condition, body):
        self.condition = condition
        self.body = body

class Program(ASTNode):
    def __init__(self, statements):
        self.statements = statements

# Parser
class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0
    
    def error(self, message="Unexpected token"):
        current_token = self.current_token()
        raise Exception(f"Parser error: {message}. Got {current_token.type if current_token else 'EOF'}")
    
    def current_token(self):
        if self.pos >= len(self.tokens):
            return self.tokens[-1]  # EOF token
        return self.tokens[self.pos]
    
    def peek_token(self, offset=1):
        pos = self.pos + offset
        if pos >= len(self.tokens):
            return self.tokens[-1]  # EOF token
        return self.tokens[pos]
    
    def advance(self):
        if self.pos < len(self.tokens) - 1:
            self.pos += 1
    
    def match(self, *token_types):
        return self.current_token().type in token_types
    
    def consume(self, token_type, message=""):
        if self.current_token().type != token_type:
            self.error(message or f"Expected {token_type}")
        token = self.current_token()
        self.advance()
        return token
    
    def skip_newlines(self):
        while self.match(TokenType.NEWLINE):
            self.advance()
    
    def parse(self):
        statements = []
        self.skip_newlines()
        
        while not self.match(TokenType.EOF):
            if self.match(TokenType.NEWLINE):
                self.advance()
                continue
            
            stmt = self.parse_statement()
            if stmt:
                statements.append(stmt)
            
            self.skip_newlines()
        
        return Program(statements)
    
    def parse_statement(self):
        if self.match(TokenType.PRINT):
            return self.parse_print()
        elif self.match(TokenType.IF):
            return self.parse_if()
        elif self.match(TokenType.WHILE):
            return self.parse_while()
        elif self.match(TokenType.IDENTIFIER) and self.peek_token().type == TokenType.ASSIGN:
            return self.parse_assignment()
        else:
            # Expression statement
            expr = self.parse_expression()
            return expr
    
    def parse_print(self):
        self.consume(TokenType.PRINT)
        self.consume(TokenType.LPAREN)
        
        arguments = []
        if not self.match(TokenType.RPAREN):
            arguments.append(self.parse_expression())
            while self.match(TokenType.COMMA):
                self.advance()
                arguments.append(self.parse_expression())
        
        self.consume(TokenType.RPAREN)
        return PrintStatement(arguments)
    
    def parse_assignment(self):
        name = self.consume(TokenType.IDENTIFIER).value
        self.consume(TokenType.ASSIGN)
        value = self.parse_expression()
        return Assignment(name, value)
    
    def parse_if(self):
        self.consume(TokenType.IF)
        condition = self.parse_expression()
        self.consume(TokenType.COLON)
        self.skip_newlines()
        
        if_body = []
        # Simple single statement for now
        if not self.match(TokenType.EOF, TokenType.ELSE):
            stmt = self.parse_statement()
            if stmt:
                if_body.append(stmt)
        
        else_body = None
        if self.match(TokenType.ELSE):
            self.advance()
            self.consume(TokenType.COLON)
            self.skip_newlines()
            
            else_body = []
            if not self.match(TokenType.EOF):
                stmt = self.parse_statement()
                if stmt:
                    else_body.append(stmt)
        
        return IfStatement(condition, if_body, else_body)
    
    def parse_while(self):
        self.consume(TokenType.WHILE)
        condition = self.parse_expression()
        self.consume(TokenType.COLON)
        self.skip_newlines()
        
        body = []
        # Simple single statement for now
        if not self.match(TokenType.EOF):
            stmt = self.parse_statement()
            if stmt:
                body.append(stmt)
        
        return WhileStatement(condition, body)
    
    def parse_expression(self):
        return self.parse_comparison()
    
    def parse_comparison(self):
        expr = self.parse_addition()
        
        while self.match(TokenType.GREATER, TokenType.LESS):
            operator = self.current_token()
            self.advance()
            right = self.parse_addition()
            expr = BinaryOp(expr, operator, right)
        
        return expr
    
    def parse_addition(self):
        expr = self.parse_multiplication()
        
        while self.match(TokenType.PLUS, TokenType.MINUS):
            operator = self.current_token()
            self.advance()
            right = self.parse_multiplication()
            expr = BinaryOp(expr, operator, right)
        
        return expr
    
    def parse_multiplication(self):
        expr = self.parse_unary()
        
        while self.match(TokenType.MULTIPLY, TokenType.DIVIDE):
            operator = self.current_token()
            self.advance()
            right = self.parse_unary()
            expr = BinaryOp(expr, operator, right)
        
        return expr
    
    def parse_unary(self):
        if self.match(TokenType.MINUS, TokenType.PLUS):
            operator = self.current_token()
            self.advance()
            expr = self.parse_unary()
            return UnaryOp(operator, expr)
        
        return self.parse_primary()
    
    def parse_primary(self):
        if self.match(TokenType.NUMBER):
            token = self.current_token()
            self.advance()
            return Number(token.value)
        
        if self.match(TokenType.STRING):
            token = self.current_token()
            self.advance()
            return String(token.value)
        
        if self.match(TokenType.IDENTIFIER):
            token = self.current_token()
            self.advance()
            return Identifier(token.value)
        
        if self.match(TokenType.LPAREN):
            self.advance()
            expr = self.parse_expression()
            self.consume(TokenType.RPAREN)
            return expr
        
        self.error("Expected number, string, identifier, or '('")

# Output handler for capturing print statements
class OutputHandler:
    def __init__(self):
        self.output = []
    
    def write(self, text):
        self.output.append(str(text))
    
    def get_output(self):
        return self.output
    
    def clear(self):
        self.output = []

# Interpreter
class Interpreter:
    def __init__(self):
        self.variables = {}
        self.output_handler = OutputHandler()
    
    def visit(self, node):
        method_name = f'visit_{type(node).__name__}'
        method = getattr(self, method_name, self.generic_visit)
        return method(node)
    
    def generic_visit(self, node):
        raise Exception(f'No visit_{type(node).__name__} method')
    
    def visit_Program(self, node):
        result = None
        for statement in node.statements:
            result = self.visit(statement)
        return result
    
    def visit_Number(self, node):
        return node.value
    
    def visit_String(self, node):
        return node.value
    
    def visit_Identifier(self, node):
        if node.name not in self.variables:
            raise Exception(f"Undefined variable: {node.name}")
        return self.variables[node.name]
    
    def visit_BinaryOp(self, node):
        left = self.visit(node.left)
        right = self.visit(node.right)
        
        if node.operator.type == TokenType.PLUS:
            if isinstance(left, str) or isinstance(right, str):
                return str(left) + str(right)
            return left + right
        elif node.operator.type == TokenType.MINUS:
            return left - right
        elif node.operator.type == TokenType.MULTIPLY:
            return left * right
        elif node.operator.type == TokenType.DIVIDE:
            if right == 0:
                raise Exception("Division by zero")
            return left / right
        elif node.operator.type == TokenType.GREATER:
            return left > right
        elif node.operator.type == TokenType.LESS:
            return left < right
        else:
            raise Exception(f"Unknown binary operator: {node.operator.type}")
    
    def visit_UnaryOp(self, node):
        operand = self.visit(node.operand)
        
        if node.operator.type == TokenType.MINUS:
            return -operand
        elif node.operator.type == TokenType.PLUS:
            return operand
        else:
            raise Exception(f"Unknown unary operator: {node.operator.type}")
    
    def visit_Assignment(self, node):
        value = self.visit(node.value)
        self.variables[node.name] = value
        return value
    
    def visit_PrintStatement(self, node):
        values = []
        for arg in node.arguments:
            value = self.visit(arg)
            values.append(str(value))
        
        output_line = " ".join(values)
        self.output_handler.write(output_line)
        return None
    
    def visit_IfStatement(self, node):
        condition = self.visit(node.condition)
        result = None
        
        if condition:
            for statement in node.if_body:
                result = self.visit(statement)
        elif node.else_body:
            for statement in node.else_body:
                result = self.visit(statement)
        
        return result
    
    def visit_WhileStatement(self, node):
        result = None
        count = 0
        while self.visit(node.condition) and count < 1000:  # Prevent infinite loops
            for statement in node.body:
                result = self.visit(statement)
            count += 1
        return result

# Global interpreter instance to maintain state
global_interpreter = Interpreter()

def run_spl_code(code):
    """Main function to execute SPL code"""
    try:
        # Use the global interpreter to maintain variable state
        global global_interpreter
        
        # Clear output from previous runs
        global_interpreter.output_handler.clear()
        
        # Parse and execute
        lexer = Lexer(code)
        tokens = lexer.tokenize()
        parser = Parser(tokens)
        ast = parser.parse()
        result = global_interpreter.visit(ast)
        
        # Return output and any result
        output = global_interpreter.output_handler.get_output()
        return {
            'success': True,
            'output': output,
            'result': result,
            'variables': dict(global_interpreter.variables)
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'output': [],
            'result': None,
            'variables': dict(global_interpreter.variables) if global_interpreter else {}
        }

print("Simple Programming Language loaded successfully!")
`;

        async function initPyodide() {
            try {
                document.getElementById('status').textContent = 'Loading Pyodide...';
                pyodide = await loadPyodide();
                console.log('Pyodide loaded successfully');
                
                document.getElementById('status').textContent = 'Loading SPL...';
                await pyodide.runPythonAsync(languageCode);
                console.log('SPL loaded successfully');
                
                // Test if the function is available
                const testResult = pyodide.runPython(`
try:
    run_spl_code("2 + 3")
    "Function works"
except Exception as e:
    f"Function error: {str(e)}"
                `);
                console.log('Test result:', testResult);
                
                document.getElementById('status').textContent = 'Ready to code!';
                document.getElementById('status').style.color = '#00ff00';
                document.getElementById('run-btn').disabled = false;
                
                return true;
            } catch (error) {
                console.error('Failed to load Pyodide:', error);
                document.getElementById('status').textContent = 'Error loading: ' + error.message;
                document.getElementById('status').style.color = '#ff4444';
                return false;
            }
        }

        function runCode() {
            const code = document.getElementById('code-editor').value;
            const outputDiv = document.getElementById('output');
            
            if (!code.trim()) {
                outputDiv.innerHTML = '<div class="error-line">No code to run!</div>';
                return;
            }
            
            // Show running status
            outputDiv.innerHTML = '<div class="output-line">Running code...</div>';
            
            // Use setTimeout to allow UI update
            setTimeout(() => {
                try {
                    // Execute the code
                    pyodide.globals.set('user_code', code);
                    const result = pyodide.runPython(`
try:
    result = run_spl_code(user_code)
    result
except Exception as e:
    {'success': False, 'error': str(e), 'output': [], 'result': None, 'variables': {}}
                    `);
                    
                    // Display output
                    let output = '';
                    if (result.success) {
                        if (result.output && result.output.length > 0) {
                            result.output.forEach(line => {
                                output += `<div class="print-line">${escapeHtml(line)}</div>`;
                            });
                        } else if (result.result !== null && result.result !== undefined) {
                            output += `<div class="output-line">Result: ${escapeHtml(result.result.toString())}</div>`;
                        } else {
                            output += '<div class="output-line">Code executed successfully</div>';
                        }
                        
                        // Show variables if any
                        if (result.variables && Object.keys(result.variables).length > 0) {
                            output += '<div class="output-line">Variables:</div>';
                            for (const [name, value] of Object.entries(result.variables)) {
                                output += `<div class="output-line">  ${name} = ${value}</div>`;
                            }
                        }
                    } else {
                        output = `<div class="error-line">${escapeHtml(result.error)}</div>`;
                    }
                    
                    outputDiv.innerHTML = output;
                    
                } catch (error) {
                    console.error('Execution error:', error);
                    outputDiv.innerHTML = `<div class="error-line">JavaScript Error: ${escapeHtml(error.message)}</div>`;
                }
            }, 50);
        }

        function clearOutput() {
            document.getElementById('output').innerHTML = 'Output cleared...';
        }

        function loadExample() {
            const examples = [
                `x = 5
y = 10
print("Hello World")
print("x + y =", x + y)`,
                `name = "Alice"
age = 25
print("Name:", name)
print("Age:", age)`,
                `a = 10
b = 3
print("Addition:", a + b)
print("Subtraction:", a - b)
print("Multiplication:", a * b)
print("Division:", a / b)`,
                `x = 1
while x <= 5:
    print("Count:", x)
    x = x + 1`,
                `score = 85
if score > 90:
    print("Grade: A")
else:
    print("Grade: B")`
            ];
            
            const randomExample = examples[Math.floor(Math.random() * examples.length)];
            document.getElementById('code-editor').value = randomExample;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('run-btn').addEventListener('click', runCode);
            document.getElementById('clear-btn').addEventListener('click', clearOutput);
            document.getElementById('example-btn').addEventListener('click', loadExample);
            
            // Ctrl+Enter to run
            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    runCode();
                }
            });
            
            initPyodide();
        });
    </script>
</body>
</html>
